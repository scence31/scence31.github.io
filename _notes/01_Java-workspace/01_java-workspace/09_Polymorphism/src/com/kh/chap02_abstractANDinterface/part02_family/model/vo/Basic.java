package com.kh.chap02_abstractANDinterface.part02_family.model.vo; // 패키지 선언부


// 인터페이스
public interface Basic {
	
	/*
	 * * 인터페이스(Interface)
	 * - 모든 필드가 "상수필드고, 모든 메소드가 추상메소드인" 일종의 "추상클래스"
	 * - "무조건" 구현해야하는 메소드가 있을 때 인터페이스를 만들어서 상속하게끔 유도할 수 있다.
	 * - 추상클래스와 다르게 좀 더 강한 규칙성, 강제성을 띔
	 * - 인터페이스는 다중상속이 허용됨
	 *   필드명이 중복되더라도 상속필드("static" final)기 때문에
	 *   어차피 클래스명.필드명으로 접근해서 이름 자체가 중복되더라도 별 영향 없음
	 *   어차피 물려받는 모든 메소드가 추상메소드기 때문에 결국 최종 구현은
	 *   자식클래스에서 단 한 번 일어나기 떄문
	 * 
	 * [표현법]
	 * 접근제한자 interface 인터페이스명 {
	 * 
	 * 		// 필드부 - 상수필드들만 (public static final)
	 * 
	 * 		// 메소드부 - 추상메소드들만 (public abstract)
	 * 
	 * }
	 * 
	 * > 인터페이스에서 필드는 무조건 상수필드, 메소드는 추상메소드
	 * > 어차피 추상클래스로 객체생성 못하므로 생성자는 작성하지 않음
	 * 
	 * * 추상클래스 VS 인터페이스
	 * 1. 공통점
	 * - 객체생성 불가능하지만 참조변수로서 사용 가능함. 즉, 다형성 적용 가능
	 * - 상속받는 자식클래스에 추상메소드를 구현(오버라이딩)하도록 강제할 수 있다.
	 * 
	 * 2. 차이점
	 * - 추상클래스는 클래스 내에 인스턴스변수(일반필드), 일반메소드 작성 가능하고
	 *   추상메소드가 포함됐거나 안됐어도 abstract 키워드로 클래스가 정의됨
	 * - 메소드 구현의 강제성은 동일하지만, 강제성의 세기가 다름
	 *   ex) 메소드 10개 물려받았는데 5개만 오버라이딩하는 경우 -> 추상클래스, 전부하는경우 -> 인터페이스
	 * 
	 * - 강제성의 세기가 다르기 때문에 개념적으로 존재하는 목적이 다르다!
	 * > 추상클래스: 코드를 상속받아 기능 이용 + 확장
	 * > 인터페이스: 코드를 상속받아 기능 구현 
	 * 
	 * 
	 */
	
	// [필드부] - 모두 상수필드
	/*public static final*/ int NUM = 10;
	// > 인터페이스는 어차피 상수필드들만 정의할 수 있어서 public static~ 생략 가능(암묵적/묵시적표현)
	
	// [메소드부] - 모두 추상메소드
	/*public abstract*/ void eat();
	
	/*public abstract*/ void sleep();
	// > public abstract 역시 생략 가능
	
}















