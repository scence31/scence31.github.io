<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
    <style>
        /* 필기용 스타일 먼저 지정*/
        .area {
            width: 300px;
            border: 1px solid blue;
        }
        .small {
            height: 150px;
        }
        .big {
            height: 300px;
        }
    </style>
</head>
<body>

    <h1>배열</h1>

    <!--
        * 자바 시간에 배웠던 배열 개념

        - 같은 자료형의 값 여러개를 묶어서 보관할 수 있음
        - 배열의 사이즈를 한 번 할당하면 사이즈 변경 불가능!
        - 자바의 참조자료형 개념(stack 영역에는 주소값, heap은 데이터 들어있는 구조)
    -->

    <p> - 자바스크립트는 별도 자료형 지정이 없어서 어떤 자료형 값들이든 다 담을 수 있음 <br>
        - 자바의 배열보다는 ArrayList와 유사함</p>

        <button onclick="arrayTest1();">확인하기</button>

        <div id="area1" class="area small"></div>

        <script>
            function arrayTest1() {

                var arr = ["홍길동", "서울", 20, true, [1, 2, 3]];

                // console.log(arr);
                console.log(arr[2]); // 20
                console.log(arr[4]); // [1, 2, 3]
                console.log(arr[4][1]); // 2
                // 배열 안에 배열: 2차원 배열

                // 출력용 div
                let area1 = document.getElementById("area1");

                // 반복문으로 div에 출력
                /*
                for(let i = 0; i < arr.length; i++) {

                    area1.innerHTML += arr[i] + "<br>";
                }
                */

                // 배열의 0번 인덱스에서부터 마지막 인덱스까지
                // 순차적으로 모두 접근할 목적으로 반복한다고 하면
                // for in문 활용 가능(자바스크립트에서 향상된for문은 없음)

                // [for in문 표현법]
                // for(변수선언문 in 배열명) 향상for문에서 : 대신 in 느낌
                for(let i in arr) {
                    // i = 0 1 2 3 4
                    // i에는 매번 각 인덱스 수가 순차적으로 담겨옴


                    // console.log(i); // 0 ~ 마지막인덱스
                    // console.log(arr[i]); // 데이터들 

                    area1.innerHTML += arr[i] + "<br>";
                }
            }
        </script>

        <br><hr>

        <h3>- 배열의 선언</h3>

        <!--
            * 자바의 배열선언방식

            자료형[] 배열명; => 선언(stack 영역에 주소값이 들어갈 상자 만듦)
            배열명 = new 자료형[사이즈]; => 할당(Heap에 영역을 확보)

            자료형[] 배열명 = new 자료형[사이즈]; ==> 선언+할당

            - 반드시 할당으로 배열이 몇 칸짜리인지 알려줘야 함(할당된 사이즈 변경 불가)
            
        -->

        <p>
            - 배열 선언시 배열의 크기에 제약이 없음(ArrayList와 유사)
        </p>

        <button onclick="arrayTest2();">확인하기</button>

        <script>
            function arrayTest2() {

                // 자바스크립트에서 배열선언 표현법
                // 1. Array 생성자함수 이용
                // 2. 대괄호로 명시적으로 작성

                var arr1 = new Array(); // 크기 0 빈 배열
                let arr2 = new Array(3); // 크기 3 빈 배열

                const arr3 = []; // 크기 0 빈 배열

                console.log(arr1);
                console.log(arr2);
                console.log(arr3);

                // 배열에 값 추가
                arr1[0] = "바나나";
                arr1[1] = "사과";
                arr1[2] = "키위";
                console.log(arr1); // 배열 크기 3으로 늘어남

                arr2[0] = "자동차";
                arr2[1] = "기차";
                arr2[2] = "도보";
                arr2[10] = "비행기";
                console.log(arr2); // 배열크기 11로 늘어남, [3]~[9]는 비어있음

                /*
                arr3[0] = 1;
                arr3[1] = 2;
                arr3[2] = 3;
                arr3[3] = 4;
                */

                // 규칙으로 반복문
                for(let i = 0; i < 4; i++) {

                    arr3[i] = i+1;
                }

                console.log(arr3);
                // 배열은 const로 선언해도 값을 변경할 수 있음
                // 또한 사이즈도 계속 늘어남. 왜?
                // 자바스크립트 또한 코드실행시 메모리의 stack, heap 사용
                // 그래서 배열 생성하면 주소값은 stack에, 데이터는 heap에 있음
                // 배열 값을 추가하더라도 stack 영역의 주소값은 고정이라서
                // const로 배열 선언해도 값 변경이 가능해짐.
                // 자바스크립트 배열도 얕은/깊은복사 있음

                // 배열 선언 초기화 동시
                var arr4 = new Array("홍길동", "임꺽정");
                let arr5 = ["java", "oracle", "front-end"];

                console.log(arr4);
                console.log(arr5);
            }
        </script>

        <br><hr>

        <h3>Array 객체의 메소드</h3>
        <!-- 배열 관련 유용한 메소드들 -->

        <h4>1) indexOf(찾고자하는요소)
            : 배열에서 해당 요소가 위치해있는 인덱스를 반환
        </h4>

        <div id="area2" class="area small"></div>

        <button onclick="indexOfTest();">확인하기</button>

        <script>
            function indexOfTest() {

                // 출력용 div 가져오기
                const area2 = document.getElementById("area2");

                var arr = ["사과", "딸기", "바나나", "복숭아", "파인애플"];

                // 사용자로부터 과일명 입력받기

                let fruit = prompt("찾을 과일명 입력");

                let index = arr.indexOf(fruit);

                // console.log(index);
                // 존재하는 데이터면 위치한 인덱스 리턴, 없는 데이터면 -1 리턴

                // 과일 있으면: 찾는 과일 xx은 x번째 인덱스에 있음
                // 없으면: 찾는 과일 xx은 판매 안함

                area2.innerHTML = "당신이 찾는 과일" + fruit + "는 ";
                
                if(index == -1) {

                    area2.innerHTML += "판매하지 않습니다.";

                } else {

                    area2.innerHTML += index + "번째 인덱스에 있습니다.";

                // 참고) 동등비교시 ===도 사용 가능
                console.log(1 == 1); // true
                console.log(1 == "1"); // true
                // ==: 동등연산자(자료형 무관 실제값만 일치하면 true)

                console.log(1 === "1"); // false
                // ===: 일치연산자(자료형과 실제값 모두 일치해야 true)
                }
            }
        </script>

        <br><hr>

        <h4>2) concat(배열명, 배열명, ...)
            : 여러 개의 배열을 결합할 때 사용
        </h4>

        <div id="area3" class="area big"></div>

        <button onclick="concatTest();">확인하기</button>

        <script>
            function concatTest() {

                // 출력용 div
                var area3 = document.getElementById("area3");

                // 테스트용 배열
                let arr1 = ["사과", "딸기"];
                let arr2 = ["자동차", "오토바이", "비행기"];

                area3.innerHTML = "arr1: " + arr1 + "<br>";
                area3.innerHTML += "arr2: " + arr2 + "<br>";

                area3.innerHTML += "arr1 기준으로 배열 합침: "
                                    + arr1.concat(arr2) + "<br>";

                area3.innerHTML += "다시 arr1: " + arr1 + "<br>";
                // concat 메소드는 원본배열에 영향을 주지 않음
                // 즉, 두 배열을 합쳐서 새로운 배열로 변환

                area3.innerHTML += "arr2 기준으로 배열 합침: "
                                    + arr2.concat(arr1) + "<br>";

                // 한번에 여러개 배열 합칠 수 있음 (arr, [1, 2], ["d", true])
            }
        </script>

        <br><hr>

        <h4>3) reverse(): 배열에 담긴 값들을 역순으로 바꿔주는 메소드</h4>

        <div id="area4" class="area small"></div>

        <button onclick="reverseTest();">확인하기</button>

        <script>
            function reverseTest() {

                // 출력용 div
                let area4 = document.getElementById("area4");

                var arr = [1, 2, 3, 4, 5];

                area4.innerHTML = "arr: " + arr + "<br>";
                area4.innerHTML += "reverse 결과: " + arr.reverse() + "<br>";
                area4.innerHTML += "다시 arr: " + arr + "<br>";
                // 원본 배열에 영향을 주는 메소드
            }
        </script>
    
        <br><hr>

        <h4>4) sort(): 배열 안에 담긴 값들을 오름차순으로 정렬해주는 메소드 <br>
                원본배열에 영향 줌(내부적으로 깊은복사같은 것 안일어남)</h4>

        <!-- 내림차순 하고싶으면? arr.sort().reverse() 메소드 체이닝하기-->

        <!-- 주의사항: sort() 메소드는 기본적으로 문자열 기준으로만 정렬함
            즉, 유니코드 값에 의한 정렬만 해줌.(아스키코드표)

            숫자 기준으로 정렬하고싶다면?
            sort 메소드 호출시 인자값으로 sort 메소드를 보조해주는 함수를 넘기기
            (자바스크립트는 함수도 값으로 취급해서)

            보조해주는 함수를 callback function이라고 함(콜백함수)

            arr2.sort(function(a, b) {return a-b;});
            a, b를 매개변수로 받고 a-b의 결과를 리턴해주는 함수임
            a-b 값이 양수인 경우(a가 더 큰 경우) => a와 b의 순서를 바꿈
            ==> 정렬됨. 내림차순하고싶으면  return b-a
        -->

        <br><hr>

        <h4>5-1) push(추가할요소)<br>
            5-2) pop(): 배열 맨 뒤 요소 제거, 제거된 요소 반환
        </h4>

        <div id="area6" class="area big"></div>

        <button onclick="pushPopTest();">확인하기</button>

        <script>
            function pushPopTest() {

                var area6 = document.getElementById("area6");

                //테스트용 배열
                let arr = ["서초동", "방배동", "역삼동", "삼성동", "대치동"];

                area6.innerHTML = "arr: " + arr + "<br>";

                arr.push("신사동");
                area6.innerHTML += "arr + push: " + arr + "<br>";
                area6.innerHTML += "arr + push 후 배열크기: " + arr.push("논현동") + "<br>";
                area6.innerHTML += "다시 arr: " + arr + "<br>";
                // 원본배열에 영향을 주는 메소드

                area6.innerHTML += "arr + pop: " + arr.pop() + "<br>";
                area6.innerHTML += "다시 arr: " + arr + "<br>";
                // 원본배열에 영향을 주는 메소드

                arr.pop();
                arr.pop();
                arr.pop();

                area6.innerHTML = "최종 arr: " + arr + "<br>";
                // 배열을 선입후출 구조로(stack 구조) 저장할 때 push/pop 사용
            }
        </script>

        <br><hr>

        <h4>6-1) unshift(추가할요소): 배열의 맨 앞에 요소를 추가하고 크기 반환<br>
            6-2) shift(): 맨 앞 요소 제거하고 제거된 요소 반환</h4>

            <!-- push/pop과 동일, 선입후출구조, 원본배열 영향줌
             
                차이점: shift 계열은 내부적으로 데이터를 한칸씩 땡기거나 가져옴

                - 선입선출로(Queue구조) 하고싶다면? unshift로 데이터 추가하고 pop으로 제거
            -->

        
        <br><hr>

        <h4>7-1) slice(시작, 끝): 배열 안 요소들을 추출해주는 메소드 <br>
            7-2) splice(시작, 제거수, 추가값): 배열 요소 추출해서 제거 및 제거한 곳에 새로운 추가값 삽입(생략가능)
        </h4>

        <div id="area8" class="area small"></div>

        <button onclick="sliceSpliceTest();">확인하기</button>

        <script>
            function sliceSpliceTest() {

                const area8 = document.getElementById("area8");

                var arr = ["자바", "오라클", "html", "css", "javascript"];

                area8.innerHTML = "arr: " + arr + "<br>";

                // slice(시작인덱스, 끝인덱스) 끝인덱스-1까지 출력(자바 ArrayList의 subList 동일)
                area8.innerHTML += "slice 결과: " + arr.slice(2, 4) + "<br>";

                area8.innerHTML += "arr: " + arr + "<br>";
                // 원본배열에 영향 X

                //splice(시작인덱스, 제거수, 추가할요소)
                area8.innerHTML += "splice 결과: " + arr.splice(2, 2, "spring") + "<br>";
                // 추가할 요소 생략하면 slice랑 동일한 결과

                area8.innerHTML += "최종 arr: " + arr + "<br>";
                // 원본배열에 영향 줌
            }
        </script>

        <br><hr>

        <h4>8) join(구분자) / toString(): 배열에 담긴 값들을 하나의 문자열로 연이어서 반환</h4>

        <div id="area9" class="area small"></div>

        <button onclick="toStringJoinTest();">확인하기</button>

        <script>
            function toStringJoinTest() {

                var area9 = document.getElementById("area9");

                //테스트할 배열 세팅
                let arr = ["나는", "오늘부터", "공부를", "시작한다!"];

                area9.innerHTML = "arr: " + arr + "<br>";
                area9.innerHTML += "toString() : " + arr.toString() + "<br>";
                // 배열명을 innerHTML을 통해 html 요소 출력할 경우 내부적으로
                // .toString() 메소드를 호출한 결과로 출력해준다.(자바와 유사)
                // join도 마찬가지임

                area9.innerHTML += "구분자 제시한 join(): " + arr.join(" ") + "<br>";
                // 구분자 포함해서 연이어 나옴



            }
        </script>

        
</body>
</html>

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>